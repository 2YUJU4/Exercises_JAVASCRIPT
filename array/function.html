<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배열 함수</title>
</head>
<body>
    <p>다음 중 좋아하는 과일의 이름을 적으시오.
        <p>딱복 / 거봉 / 청포도 / 람부탄</p>
        <input type="text" id="userInput" placeholder="과일 입력">
        <button type="button" id="complete">완료</button>
    </p>
    <script>
        let userInput = document.getElementById("userInput");
        let complete = document.getElementById("complete");
        //배열생성 -> 특정값이 그 배열의 몇번 인덱스에 있는지 확인
        /*
        indexOf(값) : 값을 인자값으로 넘겨서 해당 배열의 
        가장 첫번째 값을 찾아 그 인덱스 반환 
        -> 만약에 인자로 넘겨준 값이 존재하지 않는다면 -1을 반환
        */
      

    //    let tempArr = ['a','b','c','a']; 
    //    let index = tempArr.indexOf('a');
    //    console.log(index); //0 :  0인덱스에 담긴 a를 찾아 출력.
       
      
       
    //     let fruits = ["딱복","거봉","청포도","람부탄"];

    //     complete.addEventListener("click",function(){
    //         let input = userInput.value;
    //         let index = fruits.indexOf(input);

    //         if(index == -1){
    //             alert("입력한 값은 존재하지 않습니다");
    //         }else{
    //             alert("입력한 "+input+"은/는 배열의"+index+"에 있습니다.");
    //         }

           
           
    //     });
        

        /*
        concat(값/배열) : 값이나 배열을 결합해서 새로운 배열을 반환해주는 함수
        -> 원본 배열에 영향을 주지 않음.
        */
       /*
        let arr1 = ["바나나","딸기","수박"];
        let arr2 = ["사과","귤"];
        let arr3 = [10,20,30];

        let data1 = arr1.concat(arr2);
        console.log("data1 : ",data1);

        let data2 =  arr1.concat("망고");
        console.log("data2 : ",data2);

        let data3 = arr1.concat(arr2,arr3);
        console.log("data3 : ",data3);

        console.log("arr1 : ",arr1);
        */

        /*
            join() : 배열을 결합해 문자열로 반환
            -> 하나의 배열안의 요소들을 모두 합쳐서 문자열로 반환
            -> 인자값이없는 경우 ,(콤마)를 기준으로 요소들을 결합
            -> 인자값으로 구분자를 넘겨주면 해당 구분자를 기준으로 요소들을 결합
            원본 배열에 영향없음
        */
       /*
        let arr1 = ["바나나","딸기","수박"];
        let arr2 = ["사과","귤"];
        let arr3 = [10,20,30];

        let data1 = arr1.concat(arr2,arr3);
        console.log("data1 : ",data1);

        let data2 = data1.join();
        console.log("data2 : ",data2);

        let data3 = data1.join("+");
        console.log("data3 : ",data3);
        */
       /*
            reverse() : 배열의 순서를 뒤집어주는 함수
            -> 실제 원본 배열의 데이터 순서가 바뀜
       */
        /*
        let arr1 = [1,2,3,4,5,6,7,8,9,10];
        let arr2 = ["이유주","홍길동","세종대왕","이순신"];

        arr1.reverse();
        console.log("arr1 :",arr1);
        arr2.reverse();
        console.log("arr2 :",arr2);
        */
       /*
            sort() : 
       */
        let arr1 = ['마','가','다','바','라','나'];
        let arr2 = [5,1,6,4,8,2,3,7,10,9];
/*
        arr1.sort();
        console.log("arr1 : ",arr1);

        arr2.sort();
        console.log("arr2 : ",arr2);
*/

        /*
            sort() 함수의 인자값으로 compareFunction를 넘겨줘 오름차순, 내림차순을
            정확히 해줄 수 있음
            -> 원본 배열의 데이터 영향 받음

            sort(sortASC);
            sort(sortDESC);

            compareFunction(a,b)
             : 0보다 작은 수 반환(음수) -> a를 b보다 낮은 인덱스로 정렬 - 오름차순

            compareFunction(a,b)
             : 0을 반환 -> a와 b의 인덱스를 변경하지 않음
            
             compareFunction(a,b)
             : 0보다 큰 수 반환(양수) -> b를 a보다 낮은 인덱스로 정렬 - 내림차순

        */
       /*
        function sortASC(a,b){
            return a-b;
        }
        function sortDESC(a,b){
            return b-a;
        }

        arr2.sort(sortASC); //sort라는 함수실행될때 만들어준 sortASC를 이용해서 정렬
        console.log("arr2 : ",arr2);

        arr2.sort(sortDESC);
        console.log("arr2 : ",arr2);

        function sortStrDESC(a,b){ //문자열의 내림차순 함수
            if(a < b){
                return 1;
            }else if(a > b){
                return -1;
            }else{
                return 0;
            }
        }

        arr1.sort(sortStrDESC);
        console.log("arr1 : ",arr1);
        */
       /*
            push() : 배열의 가장 끝 인덱스에 새로운 값 추가
            pop() : 배열의 가장 끝 인덱스에 있는 값 삭제
            원본 데이터에 영향 줌
       */
      /*
      let fruit = ["apple","banana","mango"];
      fruit.push("strawberry");
      console.log("fruit : ",fruit);

      fruit.pop();
      console.log("fruit : ",fruit);
      */

        /*
            unshift(값) : 배열의 첫 인덱스에 새로운값 추가
            -> 원래 인덱스의 데이터들은 뒤로 1씩 밀려남.

            shift() : 배열의 첫 인덱스 값 삭제
            -> 원래 데이터 인덱스가 앞으로 1씩 당겨짐.
        */
       /*
        let fruit = ["apple","banana","mango"];
        fruit.unshift("watermelon");
        console.log("fruit : ",fruit);

        fruit.shift();
        console.log("fruit : ",fruit);
        */

        /*
            slice(인자1, 인자2) : 배열의 데이터를 잘라내는 함수
            -> 배열에 값이 잘려진 상태를 반환
            인자1(시작 인덱스) : 시작인덱스에서부터 데이터를 잘라서 자른 데이터를 배열로 만들어 반환
            -> 해당 인덱스 전까지 잘라내겠다.(1번 인덱스 전까지 잘라냄)
            인자2(끝 인덱스) : 시작인덱스에서부터 데이터를 끝 인덱스 전까지 잘라서 배열로 반환
            -> 끝인덱스가 없으면 배열의 끝인덱스까지 모두 달라버림

            원본 배열 영향X

        */
       /*
        let data = ['apple','mango','watermelon','pineapple','grape'];

        console.log(data.slice(1)); //['mango', 'watermelon', 'pineapple', 'grape']

        console.log(data.slice(1,3)); // ['mango', 'watermelon']
        */
        /*
            splice(index,제거수,[추가값])
             : 시작인덱스를 기준으로 해서 원하는 개수만큼 데이터를 제거할 수 있음
               + 세번째 인자인 새로운 값을 추가하는 것도 가능한 함수 

               시작 index : 해당 인덱스부터 값을 제거해라.
                (만약 index값만 넘겨주면 해당인텍스부터 나머지 인덱스 데이터 모두 삭제)

                제거수 : 몇개의 요소를 삭제할건지.
        */
        let data = ['apple','mango','watermelon','pineapple','grape'];
        //data.splice(1); //['apple']
        //data.splice(1,2);
        //data.splice(1,1,"strawberry");
        //data.splice(1,2,"strawberry"); //-> 여러개의 요소가 삭제가 되도 새로운값은 1번만 들어가게됨.
        
        //data.splice(1,0,"strawberry"); //특정값을 지정하여 중간에 데이터 삽입 가능
        data.splice(-1,1); //음수 : 뒤에서부터의 값

        
        
        console.log(data);


    </script>
</body>
</html>